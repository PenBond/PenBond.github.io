<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subscription Converter</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #1e293b;
            --accent: #3b82f6;
            --accent-hover: #2563eb;
            --text-primary: #f1f5f9;
            --text-secondary: #94a3b8;
            --border: #334155;
            --success: #22c55e;
            --radius: 12px;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #60a5fa, #a78bfa);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .protocols {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: 15px;
        }

        .protocol-badge {
            background: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .card-icon {
            font-size: 1.3rem;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 600;
        }

        .card-description {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: auto;
        }

        textarea {
            width: 100%;
            min-height: 120px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            resize: vertical;
            transition: border-color 0.2s;
        }

        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        textarea::placeholder {
            color: var(--text-secondary);
            opacity: 0.7;
        }

        .format-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .format-btn {
            flex: 1;
            min-width: 100px;
            padding: 12px 20px;
            background: var(--bg-primary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .format-btn:hover {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.1);
        }

        .format-btn.active {
            border-color: var(--accent);
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .convert-btn {
            width: 100%;
            padding: 14px;
            background: linear-gradient(135deg, var(--accent), #8b5cf6);
            border: none;
            border-radius: 8px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            margin-top: 15px;
        }

        .convert-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
        }

        .convert-btn:active {
            transform: translateY(0);
        }

        .output-section {
            margin-top: 25px;
        }

        .output-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .output-title {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .copy-btn {
            padding: 8px 16px;
            background: var(--success);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: 600;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .copy-btn:hover {
            background: #16a34a;
            transform: scale(1.02);
        }

        .copy-btn.copied {
            background: #065f46;
        }

        .output-area {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }

        .output-area:empty::before {
            content: 'Converted output will appear here...';
            color: var(--text-secondary);
            opacity: 0.6;
        }

        .stats {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid var(--border);
        }

        .stat-item {
            background: rgba(59, 130, 246, 0.1);
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 0.8rem;
            color: #60a5fa;
        }

        .stat-item span {
            font-weight: 700;
        }

        .tab-container {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .tab-btn {
            padding: 8px 16px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tab-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
        }

        .tab-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
        }

        .input-group {
            display: none;
        }

        .input-group.active {
            display: block;
        }

        .helper-text {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 8px;
        }

        @media (max-width: 600px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.4rem;
            }

            .format-btn {
                padding: 10px 15px;
                font-size: 0.9rem;
            }

            textarea {
                min-height: 100px;
            }

            .card {
                padding: 15px;
            }

            .card-description {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üîÑ Subscription Converter</h1>
            <p class="subtitle">Convert proxy nodes to different subscription formats</p>
            <div class="protocols">
                <span class="protocol-badge">VLESS</span>
                <span class="protocol-badge">Trojan</span>
                <span class="protocol-badge">Shadowsocks</span>
                <span class="protocol-badge">Hysteria2</span>
                <span class="protocol-badge">WireGuard</span>
            </div>
        </header>

        <div class="card">
            <div class="card-header">
                <span class="card-icon">üì•</span>
                <span class="card-title">Input Nodes</span>
                <span class="card-description">Paste your proxy configurations</span>
            </div>

            <div class="tab-container">
                <button class="tab-btn active" data-tab="all">All Nodes</button>
                <button class="tab-btn" data-tab="vless">VLESS</button>
                <button class="tab-btn" data-tab="trojan">Trojan</button>
                <button class="tab-btn" data-tab="ss">Shadowsocks</button>
                <button class="tab-btn" data-tab="hy2">Hysteria2</button>
                <button class="tab-btn" data-tab="wg">WireGuard</button>
                <button class="tab-btn" data-tab="subs">Subscriptions</button>
            </div>

            <div class="input-group active" id="all-input">
                <textarea id="all-nodes" placeholder="Paste all your nodes here (vless://, trojan://, ss://, hysteria2://, hy2://, wireguard://)&#10;One node per line..."></textarea>
                <p class="helper-text">Supports mixed protocols - one node per line</p>
            </div>

            <div class="input-group" id="vless-input">
                <textarea id="vless-nodes" placeholder="vless://uuid@server:port?type=ws&security=tls&...#Name&#10;vless://..."></textarea>
                <p class="helper-text">VLESS nodes with WebSocket, gRPC, TCP, XHTTP transport</p>
            </div>

            <div class="input-group" id="trojan-input">
                <textarea id="trojan-nodes" placeholder="trojan://password@server:port?type=ws&sni=...#Name&#10;trojan://..."></textarea>
                <p class="helper-text">Trojan nodes with optional WebSocket/gRPC transport</p>
            </div>

            <div class="input-group" id="ss-input">
                <textarea id="ss-nodes" placeholder="ss://base64(method:password)@server:port#Name&#10;ss://method:password@server:port#Name"></textarea>
                <p class="helper-text">Shadowsocks nodes (SIP002 format supported)</p>
            </div>

            <div class="input-group" id="hy2-input">
                <textarea id="hy2-nodes" placeholder="hysteria2://password@server:port?sni=...#Name&#10;hy2://password@server:port?...#Name"></textarea>
                <p class="helper-text">Hysteria2 nodes with optional obfs</p>
            </div>

            <div class="input-group" id="wg-input">
                <textarea id="wg-nodes" placeholder="WireGuard Config Name&#10;[Interface]&#10;PrivateKey = ...&#10;Address = 10.0.0.2/32&#10;DNS = 1.1.1.1&#10;&#10;[Peer]&#10;PublicKey = ...&#10;AllowedIPs = 0.0.0.0/0&#10;Endpoint = server:port"></textarea>
                <p class="helper-text">Standard WireGuard configuration format</p>
            </div>

            <div class="input-group" id="subs-input">
                <textarea id="sub-links" placeholder="https://example.com/subscription/link1&#10;https://example.com/subscription/link2"></textarea>
                <p class="helper-text">‚ö†Ô∏è Subscription URLs cannot be fetched in sandbox mode - paste node content directly</p>
            </div>
        </div>

        <div class="card">
            <div class="card-header">
                <span class="card-icon">‚öôÔ∏è</span>
                <span class="card-title">Output Format</span>
            </div>
            <div class="format-selector">
                <button class="format-btn active" data-format="base64">üìÑ Base64</button>
                <button class="format-btn" data-format="singbox">üì¶ Sing-box</button>
                <button class="format-btn" data-format="clash">üê± Clash</button>
            </div>
            <button class="convert-btn" onclick="convertNodes()">üöÄ Convert Now</button>
        </div>

        <div class="output-section">
            <div class="card">
                <div class="output-header">
                    <div class="output-title">
                        <span>üì§</span>
                        <span>Converted Output</span>
                        <span id="format-label" style="color: var(--text-secondary); font-weight: 400; font-size: 0.85rem;">(Base64)</span>
                    </div>
                    <button class="copy-btn" onclick="copyOutput()">
                        <span>üìã</span>
                        <span id="copy-text">Copy</span>
                    </button>
                </div>
                <div class="output-area" id="output"></div>
                <div class="stats" id="stats" style="display: none;">
                    <div class="stat-item">Total: <span id="total-count">0</span></div>
                    <div class="stat-item">VLESS: <span id="vless-count">0</span></div>
                    <div class="stat-item">Trojan: <span id="trojan-count">0</span></div>
                    <div class="stat-item">SS: <span id="ss-count">0</span></div>
                    <div class="stat-item">Hy2: <span id="hy2-count">0</span></div>
                    <div class="stat-item">WG: <span id="wg-count">0</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let selectedFormat = 'base64';
        let convertedOutput = '';

        // Tab switching
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.querySelectorAll('.input-group').forEach(g => g.classList.remove('active'));
                document.getElementById(btn.dataset.tab + '-input').classList.add('active');
            });
        });

        // Format selection
        document.querySelectorAll('.format-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.format-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                selectedFormat = btn.dataset.format;
                document.getElementById('format-label').textContent = 
                    `(${selectedFormat === 'base64' ? 'Base64' : selectedFormat === 'singbox' ? 'Sing-box JSON' : 'Clash YAML'})`;
            });
        });

        function getAllNodes() {
            const all = document.getElementById('all-nodes').value;
            const vless = document.getElementById('vless-nodes').value;
            const trojan = document.getElementById('trojan-nodes').value;
            const ss = document.getElementById('ss-nodes').value;
            const hy2 = document.getElementById('hy2-nodes').value;
            const wg = document.getElementById('wg-nodes').value;
            
            return [all, vless, trojan, ss, hy2, wg].join('\n');
        }

        function parseNodes(input) {
            const lines = input.split('\n').map(l => l.trim()).filter(Boolean);
            const nodes = { vless: [], trojan: [], ss: [], hy2: [], wg: [] };
            
            let currentWgName = '';
            let currentWgConfig = [];
            let inWgConfig = false;
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                
                if (line.startsWith('vless://')) {
                    nodes.vless.push(parseVless(line));
                } else if (line.startsWith('trojan://')) {
                    nodes.trojan.push(parseTrojan(line));
                } else if (line.startsWith('ss://')) {
                    nodes.ss.push(parseShadowsocks(line));
                } else if (line.startsWith('hysteria2://') || line.startsWith('hy2://')) {
                    nodes.hy2.push(parseHysteria2(line));
                } else if (line.toLowerCase() === '[interface]') {
                    if (inWgConfig && currentWgConfig.length > 0) {
                        nodes.wg.push(parseWireGuard(currentWgConfig.join('\n'), currentWgName));
                    }
                    inWgConfig = true;
                    currentWgConfig = [line];
                    // Check previous line for name
                    if (i > 0 && !lines[i-1].includes('://') && !lines[i-1].includes('=') && !lines[i-1].startsWith('[')) {
                        currentWgName = lines[i-1];
                    } else {
                        currentWgName = 'WireGuard-' + (nodes.wg.length + 1);
                    }
                } else if (inWgConfig) {
                    currentWgConfig.push(line);
                    if (line.toLowerCase().startsWith('endpoint') || 
                        (i === lines.length - 1) || 
                        (i < lines.length - 1 && (lines[i+1].startsWith('vless://') || 
                         lines[i+1].startsWith('trojan://') || lines[i+1].startsWith('ss://') ||
                         lines[i+1].startsWith('hysteria2://') || lines[i+1].startsWith('hy2://')))) {
                        nodes.wg.push(parseWireGuard(currentWgConfig.join('\n'), currentWgName));
                        inWgConfig = false;
                        currentWgConfig = [];
                    }
                }
            }
            
            if (inWgConfig && currentWgConfig.length > 0) {
                nodes.wg.push(parseWireGuard(currentWgConfig.join('\n'), currentWgName));
            }
            
            return nodes;
        }

        function parseVless(url) {
            try {
                const urlObj = new URL(url);
                const params = urlObj.searchParams;
                let name = urlObj.hash ? decodeURIComponent(urlObj.hash.slice(1)) : 'vless-node';
                
                return {
                    type: 'vless',
                    name: name,
                    server: urlObj.hostname.replace(/^\[|\]$/g, ''),
                    port: parseInt(urlObj.port) || 443,
                    uuid: urlObj.username,
                    transport: params.get('type') || 'tcp',
                    security: params.get('security') || '',
                    sni: params.get('sni') || urlObj.hostname,
                    host: params.get('host') || '',
                    path: params.get('path') || '/',
                    serviceName: params.get('serviceName') || params.get('sn') || '',
                    flow: params.get('flow') || '',
                    fp: params.get('fp') || 'chrome',
                    pbk: params.get('pbk') || '',
                    sid: params.get('sid') || '',
                    alpn: params.get('alpn') || '',
                    raw: url
                };
            } catch (e) {
                return null;
            }
        }

        function parseTrojan(url) {
            try {
                const urlObj = new URL(url);
                const params = urlObj.searchParams;
                let name = urlObj.hash ? decodeURIComponent(urlObj.hash.slice(1)) : 'trojan-node';
                
                return {
                    type: 'trojan',
                    name: name,
                    server: urlObj.hostname.replace(/^\[|\]$/g, ''),
                    port: parseInt(urlObj.port) || 443,
                    password: decodeURIComponent(urlObj.username),
                    transport: params.get('type') || 'tcp',
                    sni: params.get('sni') || params.get('peer') || urlObj.hostname,
                    host: params.get('host') || '',
                    path: params.get('path') || '/',
                    serviceName: params.get('serviceName') || params.get('sn') || '',
                    fp: params.get('fp') || '',
                    alpn: params.get('alpn') || '',
                    raw: url
                };
            } catch (e) {
                return null;
            }
        }

        function parseShadowsocks(url) {
            try {
                let workingUrl = url;
                let name = 'ss-node';
                
                const hashIndex = workingUrl.indexOf('#');
                if (hashIndex !== -1) {
                    try {
                        name = decodeURIComponent(workingUrl.substring(hashIndex + 1));
                    } catch (e) {
                        name = workingUrl.substring(hashIndex + 1);
                    }
                    workingUrl = workingUrl.substring(0, hashIndex);
                }
                
                workingUrl = workingUrl.replace(/^ss:\/\//, '');
                
                let method, password, server, port;
                
                const atIndex = workingUrl.lastIndexOf('@');
                if (atIndex !== -1) {
                    const userInfo = workingUrl.substring(0, atIndex);
                    const serverPart = workingUrl.substring(atIndex + 1);
                    
                    let decodedUserInfo;
                    try {
                        decodedUserInfo = atob(userInfo);
                        if (!decodedUserInfo.includes(':')) {
                            decodedUserInfo = userInfo;
                        }
                    } catch (e) {
                        decodedUserInfo = userInfo;
                    }
                    
                    const colonIndex = decodedUserInfo.indexOf(':');
                    if (colonIndex !== -1) {
                        method = decodedUserInfo.substring(0, colonIndex);
                        password = decodedUserInfo.substring(colonIndex + 1);
                    }
                    
                    const serverColonIndex = serverPart.lastIndexOf(':');
                    server = serverPart.substring(0, serverColonIndex);
                    port = parseInt(serverPart.substring(serverColonIndex + 1));
                } else {
                    const decoded = atob(workingUrl);
                    const atIdx = decoded.lastIndexOf('@');
                    const userPart = decoded.substring(0, atIdx);
                    const serverPart = decoded.substring(atIdx + 1);
                    
                    const colonIdx = userPart.indexOf(':');
                    method = userPart.substring(0, colonIdx);
                    password = userPart.substring(colonIdx + 1);
                    
                    const serverColonIdx = serverPart.lastIndexOf(':');
                    server = serverPart.substring(0, serverColonIdx);
                    port = parseInt(serverPart.substring(serverColonIdx + 1));
                }
                
                return {
                    type: 'ss',
                    name: name,
                    server: server,
                    port: port,
                    method: method,
                    password: password,
                    raw: url
                };
            } catch (e) {
                return null;
            }
        }

        function parseHysteria2(url) {
            try {
                const normalizedUrl = url.replace(/^hy2:\/\//, 'hysteria2://');
                const urlObj = new URL(normalizedUrl);
                const params = urlObj.searchParams;
                let name = urlObj.hash ? decodeURIComponent(urlObj.hash.slice(1)) : 'hy2-node';
                
                let password = urlObj.username || params.get('password') || '';
                password = decodeURIComponent(password);
                
                return {
                    type: 'hy2',
                    name: name,
                    server: urlObj.hostname.replace(/^\[|\]$/g, ''),
                    port: parseInt(urlObj.port) || 443,
                    password: password,
                    sni: params.get('sni') || urlObj.hostname,
                    obfs: params.get('obfs') || '',
                    obfsPassword: params.get('obfs-password') || '',
                    raw: url
                };
            } catch (e) {
                return null;
            }
        }

        function parseWireGuard(configText, name) {
            try {
                const config = { interface: {}, peer: {} };
                let currentSection = null;
                
                for (const line of configText.split('\n')) {
                    const trimmed = line.trim();
                    if (trimmed.toLowerCase() === '[interface]') {
                        currentSection = 'interface';
                    } else if (trimmed.toLowerCase() === '[peer]') {
                        currentSection = 'peer';
                    } else if (currentSection && trimmed.includes('=')) {
                        const eqIdx = trimmed.indexOf('=');
                        const key = trimmed.substring(0, eqIdx).trim().toLowerCase();
                        const value = trimmed.substring(eqIdx + 1).trim();
                        
                        if (currentSection === 'interface') {
                            if (key === 'privatekey') config.interface.privateKey = value;
                            else if (key === 'address') config.interface.address = value.split(',').map(a => a.trim());
                            else if (key === 'dns') config.interface.dns = value.split(',').map(d => d.trim());
                            else if (key === 'mtu') config.interface.mtu = parseInt(value);
                            else if (key === 'reserved') {
                                config.interface.reserved = value.replace(/^\[|\]$/g, '').split(',').map(v => parseInt(v.trim()));
                            }
                        } else if (currentSection === 'peer') {
                            if (key === 'publickey') config.peer.publicKey = value;
                            else if (key === 'allowedips') config.peer.allowedIPs = value.split(',').map(a => a.trim());
                            else if (key === 'endpoint') config.peer.endpoint = value;
                            else if (key === 'presharedkey') config.peer.preSharedKey = value;
                        }
                    }
                }
                
                if (!config.peer.endpoint || !config.interface.privateKey || !config.peer.publicKey) {
                    return null;
                }
                
                const endpointParts = config.peer.endpoint.match(/^(?:\[([^\]]+)\]|([^:]+)):(\d+)$/);
                if (!endpointParts) return null;
                
                const server = endpointParts[1] || endpointParts[2];
                const port = parseInt(endpointParts[3]);
                
                return {
                    type: 'wg',
                    name: name || 'wireguard-node',
                    server: server,
                    port: port,
                    privateKey: config.interface.privateKey,
                    publicKey: config.peer.publicKey,
                    address: config.interface.address || ['10.0.0.2/32'],
                    dns: config.interface.dns || [],
                    mtu: config.interface.mtu || 1280,
                    reserved: config.interface.reserved || [],
                    allowedIPs: config.peer.allowedIPs || ['0.0.0.0/0', '::/0'],
                    preSharedKey: config.peer.preSharedKey || ''
                };
            } catch (e) {
                return null;
            }
        }

        function generateBase64(nodes) {
            const lines = [];
            
            nodes.vless.filter(Boolean).forEach(n => lines.push(n.raw));
            nodes.trojan.filter(Boolean).forEach(n => lines.push(n.raw));
            nodes.ss.filter(Boolean).forEach(n => lines.push(n.raw));
            nodes.hy2.filter(Boolean).forEach(n => lines.push(n.raw));
            nodes.wg.filter(Boolean).forEach(n => {
                const params = new URLSearchParams();
                params.set('publickey', n.publicKey);
                if (n.address) params.set('address', n.address.join(','));
                if (n.reserved && n.reserved.length === 3) params.set('reserved', n.reserved.join(','));
                if (n.mtu) params.set('mtu', String(n.mtu));
                lines.push(`wireguard://${encodeURIComponent(n.privateKey)}@${n.server}:${n.port}?${params.toString()}#${encodeURIComponent(n.name)}`);
            });
            
            return btoa(unescape(encodeURIComponent(lines.join('\n'))));
        }

        function generateSingbox(nodes) {
            const config = {
                "log": { "level": "info" },
                "outbounds": [{ "type": "direct", "tag": "direct" }],
                "endpoints": []
            };
            
            const allOutbounds = [];
            const allEndpoints = [];
            
            nodes.vless.filter(Boolean).forEach(n => {
                const outbound = {
                    "type": "vless",
                    "tag": n.name,
                    "server": n.server,
                    "server_port": n.port,
                    "uuid": n.uuid
                };
                
                if (n.security === 'tls' || n.security === 'reality') {
                    outbound.tls = {
                        "enabled": true,
                        "server_name": n.sni,
                        "insecure": false
                    };
                    if (n.security === 'reality') {
                        outbound.tls.reality = {
                            "enabled": true,
                            "public_key": n.pbk,
                            "short_id": n.sid
                        };
                    }
                }
                
                if (n.transport === 'ws') {
                    outbound.transport = {
                        "type": "ws",
                        "path": n.path,
                        "headers": { "Host": n.host || n.sni }
                    };
                } else if (n.transport === 'grpc') {
                    outbound.transport = {
                        "type": "grpc",
                        "service_name": n.serviceName
                    };
                }
                
                if (n.flow) outbound.flow = n.flow;
                
                allOutbounds.push(outbound);
            });
            
            nodes.trojan.filter(Boolean).forEach(n => {
                const outbound = {
                    "type": "trojan",
                    "tag": n.name,
                    "server": n.server,
                    "server_port": n.port,
                    "password": n.password,
                    "tls": {
                        "enabled": true,
                        "server_name": n.sni,
                        "insecure": false
                    }
                };
                
                if (n.transport === 'ws') {
                    outbound.transport = {
                        "type": "ws",
                        "path": n.path,
                        "headers": { "Host": n.host || n.sni }
                    };
                } else if (n.transport === 'grpc') {
                    outbound.transport = {
                        "type": "grpc",
                        "service_name": n.serviceName
                    };
                }
                
                allOutbounds.push(outbound);
            });
            
            nodes.ss.filter(Boolean).forEach(n => {
                allOutbounds.push({
                    "type": "shadowsocks",
                    "tag": n.name,
                    "server": n.server,
                    "server_port": n.port,
                    "method": n.method,
                    "password": n.password
                });
            });
            
            nodes.hy2.filter(Boolean).forEach(n => {
                const outbound = {
                    "type": "hysteria2",
                    "tag": n.name,
                    "server": n.server,
                    "server_port": n.port,
                    "password": n.password,
                    "tls": {
                        "enabled": true,
                        "server_name": n.sni,
                        "insecure": false,
                        "alpn": ["h3"]
                    }
                };
                
                if (n.obfs && n.obfs !== 'none') {
                    outbound.obfs = { "type": n.obfs, "password": n.obfsPassword };
                }
                
                allOutbounds.push(outbound);
            });
            
            nodes.wg.filter(Boolean).forEach(n => {
                allEndpoints.push({
                    "type": "wireguard",
                    "tag": n.name,
                    "mtu": n.mtu,
                    "address": n.address,
                    "private_key": n.privateKey,
                    "peers": [{
                        "address": n.server,
                        "port": n.port,
                        "public_key": n.publicKey,
                        "allowed_ips": n.allowedIPs,
                        ...(n.preSharedKey ? { "pre_shared_key": n.preSharedKey } : {}),
                        ...(n.reserved.length === 3 ? { "reserved": n.reserved } : {})
                    }]
                });
            });
            
            const proxyTags = [...allOutbounds.map(o => o.tag), ...allEndpoints.map(e => e.tag)];
            
            if (proxyTags.length > 0) {
                config.outbounds.unshift({
                    "type": "selector",
                    "tag": "üöÄ Proxy",
                    "outbounds": proxyTags,
                    "default": proxyTags[0]
                });
                
                if (proxyTags.length > 1) {
                    config.outbounds.push({
                        "type": "urltest",
                        "tag": "‚ö° Auto",
                        "outbounds": proxyTags,
                        "url": "https://www.gstatic.com/generate_204",
                        "interval": "3m"
                    });
                }
            }
            
            config.outbounds.push(...allOutbounds);
            if (allEndpoints.length > 0) {
                config.endpoints = allEndpoints;
            } else {
                delete config.endpoints;
            }
            
            return JSON.stringify(config, null, 2);
        }

        function generateClash(nodes) {
            let yaml = `# Clash Meta Configuration
# Generated by Subscription Converter

mixed-port: 7890
allow-lan: true
mode: rule
log-level: info

proxies:\n`;
            
            nodes.vless.filter(Boolean).forEach(n => {
                yaml += `  - name: "${n.name}"\n`;
                yaml += `    type: vless\n`;
                yaml += `    server: ${n.server}\n`;
                yaml += `    port: ${n.port}\n`;
                yaml += `    uuid: ${n.uuid}\n`;
                yaml += `    udp: true\n`;
                
                if (n.security === 'tls') {
                    yaml += `    tls: true\n`;
                    yaml += `    servername: ${n.sni}\n`;
                    yaml += `    skip-cert-verify: false\n`;
                } else if (n.security === 'reality') {
                    yaml += `    tls: true\n`;
                    yaml += `    servername: ${n.sni}\n`;
                    yaml += `    reality-opts:\n`;
                    yaml += `      public-key: ${n.pbk}\n`;
                    yaml += `      short-id: ${n.sid}\n`;
                    yaml += `    client-fingerprint: chrome\n`;
                }
                
                if (n.transport === 'ws') {
                    yaml += `    network: ws\n`;
                    yaml += `    ws-opts:\n`;
                    yaml += `      path: ${n.path}\n`;
                    yaml += `      headers:\n`;
                    yaml += `        Host: ${n.host || n.sni}\n`;
                } else if (n.transport === 'grpc') {
                    yaml += `    network: grpc\n`;
                    yaml += `    grpc-opts:\n`;
                    yaml += `      grpc-service-name: ${n.serviceName}\n`;
                }
                
                if (n.flow) yaml += `    flow: ${n.flow}\n`;
                yaml += '\n';
            });
            
            nodes.trojan.filter(Boolean).forEach(n => {
                yaml += `  - name: "${n.name}"\n`;
                yaml += `    type: trojan\n`;
                yaml += `    server: ${n.server}\n`;
                yaml += `    port: ${n.port}\n`;
                yaml += `    password: ${n.password}\n`;
                yaml += `    udp: true\n`;
                yaml += `    sni: ${n.sni}\n`;
                yaml += `    skip-cert-verify: false\n`;
                
                if (n.transport === 'ws') {
                    yaml += `    network: ws\n`;
                    yaml += `    ws-opts:\n`;
                    yaml += `      path: ${n.path}\n`;
                    yaml += `      headers:\n`;
                    yaml += `        Host: ${n.host || n.sni}\n`;
                } else if (n.transport === 'grpc') {
                    yaml += `    network: grpc\n`;
                    yaml += `    grpc-opts:\n`;
                    yaml += `      grpc-service-name: ${n.serviceName}\n`;
                }
                yaml += '\n';
            });
            
            nodes.ss.filter(Boolean).forEach(n => {
                yaml += `  - name: "${n.name}"\n`;
                yaml += `    type: ss\n`;
                yaml += `    server: ${n.server}\n`;
                yaml += `    port: ${n.port}\n`;
                yaml += `    cipher: ${n.method}\n`;
                yaml += `    password: ${n.password}\n`;
                yaml += `    udp: true\n\n`;
            });
            
            nodes.hy2.filter(Boolean).forEach(n => {
                yaml += `  - name: "${n.name}"\n`;
                yaml += `    type: hysteria2\n`;
                yaml += `    server: ${n.server}\n`;
                yaml += `    port: ${n.port}\n`;
                yaml += `    password: ${n.password}\n`;
                yaml += `    sni: ${n.sni}\n`;
                yaml += `    skip-cert-verify: false\n`;
                yaml += `    alpn:\n      - h3\n`;
                if (n.obfs && n.obfs !== 'none') {
                    yaml += `    obfs: ${n.obfs}\n`;
                    yaml += `    obfs-password: ${n.obfsPassword}\n`;
                }
                yaml += '\n';
            });
            
            nodes.wg.filter(Boolean).forEach(n => {
                yaml += `  - name: "${n.name}"\n`;
                yaml += `    type: wireguard\n`;
                yaml += `    server: ${n.server}\n`;
                yaml += `    port: ${n.port}\n`;
                yaml += `    private-key: ${n.privateKey}\n`;
                yaml += `    public-key: ${n.publicKey}\n`;
                if (n.address[0]) yaml += `    ip: ${n.address[0].split('/')[0]}\n`;
                yaml += `    udp: true\n`;
                if (n.mtu) yaml += `    mtu: ${n.mtu}\n`;
                if (n.reserved.length === 3) yaml += `    reserved: [${n.reserved.join(', ')}]\n`;
                yaml += '\n';
            });
            
            const allNames = [
                ...nodes.vless.filter(Boolean).map(n => n.name),
                ...nodes.trojan.filter(Boolean).map(n => n.name),
                ...nodes.ss.filter(Boolean).map(n => n.name),
                ...nodes.hy2.filter(Boolean).map(n => n.name),
                ...nodes.wg.filter(Boolean).map(n => n.name)
            ];
            
            yaml += `proxy-groups:\n`;
            yaml += `  - name: "üöÄ Proxy"\n`;
            yaml += `    type: select\n`;
            yaml += `    proxies:\n`;
            if (allNames.length > 1) yaml += `      - "‚ö° Auto"\n`;
            allNames.forEach(name => yaml += `      - "${name}"\n`);
            yaml += `      - DIRECT\n\n`;
            
            if (allNames.length > 1) {
                yaml += `  - name: "‚ö° Auto"\n`;
                yaml += `    type: url-test\n`;
                yaml += `    proxies:\n`;
                allNames.forEach(name => yaml += `      - "${name}"\n`);
                yaml += `    url: "https://www.gstatic.com/generate_204"\n`;
                yaml += `    interval: 180\n\n`;
            }
            
            yaml += `rules:\n`;
            yaml += `  - GEOIP,CN,DIRECT\n`;
            yaml += `  - MATCH,üöÄ Proxy\n`;
            
            return yaml;
        }

        function convertNodes() {
            const input = getAllNodes();
            const nodes = parseNodes(input);
            
            const counts = {
                vless: nodes.vless.filter(Boolean).length,
                trojan: nodes.trojan.filter(Boolean).length,
                ss: nodes.ss.filter(Boolean).length,
                hy2: nodes.hy2.filter(Boolean).length,
                wg: nodes.wg.filter(Boolean).length
            };
            
            const total = counts.vless + counts.trojan + counts.ss + counts.hy2 + counts.wg;
            
            if (total === 0) {
                document.getElementById('output').textContent = 'No valid nodes found. Please check your input.';
                document.getElementById('stats').style.display = 'none';
                convertedOutput = '';
                return;
            }
            
            switch (selectedFormat) {
                case 'base64':
                    convertedOutput = generateBase64(nodes);
                    break;
                case 'singbox':
                    convertedOutput = generateSingbox(nodes);
                    break;
                case 'clash':
                    convertedOutput = generateClash(nodes);
                    break;
            }
            
            document.getElementById('output').textContent = convertedOutput;
            document.getElementById('stats').style.display = 'flex';
            document.getElementById('total-count').textContent = total;
            document.getElementById('vless-count').textContent = counts.vless;
            document.getElementById('trojan-count').textContent = counts.trojan;
            document.getElementById('ss-count').textContent = counts.ss;
            document.getElementById('hy2-count').textContent = counts.hy2;
            document.getElementById('wg-count').textContent = counts.wg;
        }

        function copyOutput() {
            if (!convertedOutput) return;
            
            const btn = document.querySelector('.copy-btn');
            const copyText = document.getElementById('copy-text');
            
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(convertedOutput).then(() => {
                    btn.classList.add('copied');
                    copyText.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.classList.remove('copied');
                        copyText.textContent = 'Copy';
                    }, 2000);
                });
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = convertedOutput;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    btn.classList.add('copied');
                    copyText.textContent = 'Copied!';
                    setTimeout(() => {
                        btn.classList.remove('copied');
                        copyText.textContent = 'Copy';
                    }, 2000);
                } catch (e) {
                    copyText.textContent = 'Failed';
                }
                document.body.removeChild(textArea);
            }
        }
    </script>
</body>
</html>
